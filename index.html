<!DOCTYPE html>
<meta charset="utf-8">

 <link rel="stylesheet" href="./js/dojo-release-1.10.4-src/dijit/themes/claro/claro.css"/>
 <link rel="stylesheet" href="./stratigraphic.css" />


<body class="claro">
<h1>Stratigraphic API Plots - Tester</h1>

<div class="demo-controls-container data-selection">
	<h2>Select Dataset Type and Dataset ID</h3>
	<div class="control-row">
		<label for="fsDataType">Select data type:</label>
		<select data-dojo-type="dijit/form/FilteringSelect" 
			data-dojo-props="searchAttr: 'value', placeHolder:'select dataset type', promptMessage: 'Type or select dataset type'" 
			id="fsDataType" name="fsDataTypes" >
			<option value="pollen">pollen</option>
			<option value="ostracode">ostracode</option>
			<option value="diatom">diatom</option>
			<option value="vertebrate fauna" >vertebrate fauna</option>
		</select>
	</div>
	<div class="control-row">
		<label for="fsDatasetID">Dataset Id:</label>
		<div data-dojo-type="dijit/form/FilteringSelect" id="fsDatasetID" data-dojo-props="searchAttr:'DatasetID', placeHolder:'select dataset id', autoComplete: true, required: false, maxHeight: 200">
		</div>
	</div>
	<div class="dataset-metadata"></div>
</div>

	<h2 class="diagram-heading">Stratigraphic Diagram</h2>
	<h3 id="label-site-dataset"></h3>	
	<div class="taxa-labels"></div>
	<div class="charts"></div>

<h2 id="demo-controls-label">Demo controls:</h2>
<div id="left-col">
<div  class="demo-controls-container chart-filter">
	
	<h4 id="demo-controls-description">Filter and Group Data</h4>

	<div class="control-row">
		<label for="genusGroup">Enter genus to group by (separate with ";"):</label>
		<input type="text" name="firstname" value=""
		    data-dojo-type="dijit/form/TextBox"
		    data-dojo-props="placeHolder:'Enter genus, separate with ;'" id="genusGroup" />
	</div>
	<div class="control-row">
		<label for="fsVariableUnit">Variable Unit:</label>
		<select data-dojo-type="dijit/form/FilteringSelect" id="fsVariableUnits" data-dojo-props="searchAttr:'variableunits', placeHolder:'select variable units', autoComplete: true, required: false"></select>
	</div>

	<div class="control-row">
		<label for="topxSpinner">Top Taxa:</label>
		<input data-dojo-type="dijit/form/NumberSpinner"
		    id="topxSpinner"
		    value="10"
		    style="width:42px"
		    data-dojo-props="smallDelta:1, constraints:{min:5,max:15,places:0},intermediateChanges:true"
		    name="topxSpinner">
	</div>
	<div class="control-row">
		<button data-dojo-type="dijit/form/Button" id="btnApplyFilterAndGroup">Apply Filter & Group Settings</button>
	</div>
</div>
<div  class="demo-controls-container chart-filter" id="interactionForm" data-dojo-type="dijit/form/Form">
	<h4>Chart Interaction</h4>
	<div class="control-row">
		<div data-dojo-type="dojo/store/Memory"
		    data-dojo-id="yAxisStore"
		    data-dojo-props="data: [{domainname: 'Depth', chronologyid: null, unittype: 'Depth' }]">
		</div>
		<label for="fsSelectYaxis">Y Axis: </label>
		<div data-dojo-type="dijit/form/FilteringSelect" id="fsSelectYAxis" data-dojo-props="searchAttr: 'domainname', placeHolder:'select y axis domain', promptMessage: 'Type or select chronology or depth'">
		</div>
	</div>

	<div class="control-row">
		<label for="chartTypeForm">Select Chart Type:</label>
		<form id="chartTypeForm" style="display:inline;" name="chartTypeForm" >
			<input data-dojo-type="dijit/form/RadioButton" class="chartRadio" name="chartTypeRadioButtons" data-lpignore="true" id="radioFilledArea" name="chartType" value="FilledArea" >
			<label for="radioFilledArea">Filled Area</label>
			<input data-dojo-type="dijit/form/RadioButton" class="chartRadio"  name="chartTypeRadioButtons" data-lpignore="true"  id="radioBarChart" name="chartType" value="BarChart">
			<label for="radioBarChart">Bar Chart</label>
			<input data-dojo-type="dijit/form/RadioButton" class="chartRadio"  name="chartTypeRadioButtons" data-lpignore="true"  id="radioSymbolPlot" name="chartType" value="SymbolPlot">
			<label for="radioSymbolPlot">Symbol Plot</label>
		</form>
	</div>

	<div class="area-controls control-row">
		<label for="showExaggeration">Show 5x Exaggeration</label>
		<input type="checkbox" id ="showExaggeration" checked="true">
	</div>
</div>
</div>
<div id="right-col">
<div id="legend">
	<h4 class="legend-title">Ecology Group ID</h4>
	<div class="legend-container"></div>
</div>
</div>
</body>



<link rel="stylesheet" href="./stratigraphic.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/4.6.0/d3.min.js" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3-queue/3.0.3/d3-queue.min.js"></script>

<script src="https://d3js.org/d3-request.v1.min.js"></script>

<script>
    var appRoot = "/stratigraphic-plot-pollen/";
    var dojoConfig = {
            isDebug: 1,
            async: 1,
    };      
</script> 

<script src="./js/dojo-release-1.10.4-src/dojo/dojo.js"></script>

<script src="./js/sd-data-retrieval.js" ></script>
<script src="./js/sd-tester-ui.js" ></script>
<script src="./js/sd-model.js" ></script>

<script type="text/javascript">
    var busy;
    var topic;
    var fsbusy;
    var initialized = false;


    require(["dojo/parser", "dijit/registry", "dojo/store/Memory", "dojo/request/xhr", "dojox/widget/Standby", "dojo/topic", "dojo/on", "dojo/dom", "dojo/query", "dijit/layout/BorderContainer", "dijit/layout/ContentPane", "dijit/form/FilteringSelect", "dijit/layout/ContentPane", "dijit/form/RadioButton",  "dojo/domReady!"],
    	//omit "neotoma/form/StratigraphicDiagram",
    function (parser, registry, Memory, xhr, Standby, ltopic, on, dom, query) {
        /*set globals*/
        topic = ltopic;


        parser.parse().then(
            function () {
            /*
                // cache diagrammer
                dojo.config.diagrammer = registry.byId("diagrammer");
                if (dojo.config.diagrammer == null) {
                    alert("Can't find diagrammer.");
                    return;
                }

                // initialize chronologies
                dojo.config.diagrammer.chronologies = [];
			*/
                // set up standby
                var chartContainer = query(".charts")[0];
                busy = new Standby({ target: chartContainer });
                document.body.appendChild(busy.domNode);
                busy.startup();

                // listen to show and hide busy Standby
                topic.subscribe("diagrammer/ShowStandby",
                    function () {
                        busy.show();
                    }
                );
                topic.subscribe("diagrammer/HideStandby",
                    function () {
                        busy.hide();
                    }
                );

				//clear parsed filteringselect
				//clearDatasetType();
				bindListeners();

				instantiateFSBusy();

			/*	
				//get default dataset type ids
				var defaultDSType;
				var dijitfsDataType = dijit.registry.byId("fsDataType");
				if(dijitfsDataType){
					defaultDSType = dijitfsDataType.get("value");
				}
				
				if(defaultDSType){
					 xhr.get("http://api.neotomadb.org/v1/data/datasets?datasettype="+defaultDSType,  
		                       {
		                           handleAs: "json",
		                           headers: {
		                               "X-Requested-With": null
		                           }
		                       }
		                   ).then(
		                       function (response) {
		                           if (response.success === 1) {
		                               var datasetIds = registry.byId("fsDatasetID");
		                               datasetIds.set("store",
		                                   new Memory(
		                                       {
		                                           idProperty: "DatasetID",
		                                           data: response.data
		                                       }
		                                   )
		                               );
		                           } else {
		                               alert("Error getting pollen datasetids");
		                           }
		                           
		                       },
		                       function (response) {
		                           console.log("Error on server loading pollen datasets: " + response);
		                       }
		                   );	
				}
				END skip load default datatype
				*/	
				//TESTING
				//load local dataset
				setDefaultSelection();				
				
            },
            function (err) {
                alert("error parsing");
            }
        );//end parse
		

});//end require
/*
	d3.request("http://api.neotomadb.org/v1/data/Downloads/17723?)
	    //.header("X-Requested-With", "XMLHttpRequest")
	    //.header("Content-Type", "application/x-www-form-urlencoded")
	    //.post("a=2&b=3", callback);
*/
	/*GLOBAL VARS */
	var plot_size = {h: 280, w: 300};
	var chartIntervalWidth = 8;
	var fixedWidth = 50;
	var chartGapLeft = 5;
	var chartGapRight = 12;

	var margin = {top: 15, right: 50, bottom: 28, left: 80};

	var longLabelHeight = 150;

	var width = plot_size.w - margin.left - margin.right,
	    height = plot_size.h - margin.top - margin.bottom;

	var strataYScale, strataXScale, yAxis, 
		sampleData, SampleIDMap, summaryDataBySampleID, currentChronologyName, taxaRenderObjects, 
		sortedtaxaRenderObjects, metadata, handlerChangeDatasetID, handlerChangeDatasetType;
	//var currentTopX = 10; 

	var tooltip = d3.select("body").append("div")   
        .attr("class", "tooltip")               
        .style("opacity", 0);

    //color scheme
    var colors20 = d3.scaleOrdinal(d3.schemeCategory10);

	var colorMap = {
		"TRSH": "#877F13",
		"UPHE": "#C4A64D",
		"VACR": "#BF3E21",
		"BNTH": "#313695",
		"NEKT": "#3f007d",
		"DIAT": "#EC7014"
	};

	var taxaline, taxaarea, taxaline5x, taxaarea5x, yAxisParameter, currentDatasetType;
	var defaultDatasetID = 7685;//17851;//17723;

	function instantiateFSBusy(){
		require(["dojo/query","dojox/widget/Standby", "dojo/topic"],function(query, Standby,topic){
			var fsFacade = query("#widget_fsDatasetID")[0];
	        fsbusy = new Standby({ target: fsFacade });
	        document.body.appendChild(fsbusy.domNode);
	        fsbusy.startup();

	        // listen to show and hide busy Standby
	        topic.subscribe("datasetselect/ShowStandby",
	            function () {
	                fsbusy.show();
	            }
	        );
	        topic.subscribe("datasetselect/HideStandby",
	            function () {
	                fsbusy.hide();
	            }
	        );
    	});
	}

	var apiURL = "//localhost:3010/v1.5/data/Downloads/"
	function apiDownloadDataset(datasetid){
		d3.json(apiURL+datasetid+"?", handleResult);
		//.mimeType("application/json")
	    //.get(handleResult);
	}

	function setDefaultSelection(){
		require(["dijit/registry","dojo/on", "dojo/dom"],function(registry,on,dom){
			//set dataset type fs
			var fsDatasetType = registry.byId("fsDataType");
			fsDatasetType.set("value","vertebrate fauna");


			var dijitRBSymbolPlot = registry.byId("radioSymbolPlot");
			var dijitRBBarChart = registry.byId("radioBarChart");
			var dijitRBFilledArea = registry.byId("radioFilledArea");
			
			var toggle5xControl = dom.byId("showExaggeration");
			var yAxisSelect = registry.byId("fsSelectYAxis");
			var topxSpinner = registry.byId("topxSpinner");
			var groupGenus = registry.byId("genusGroup");
			var fsVarUnit = registry.byId("fsVariableUnits");

			dijitRBFilledArea.set("selected",true);
			fsVarUnit.set("value","NISP");


		});
		
	}




	function filterEcolGroup(){

	}

	function showAll(){

	}

	
	function defineNumericRenderers(){

	}

	function updateChartTitle(dataset){
		var h3 = d3.select("#label-site-dataset")
			.html("Site: "+dataset.site.sitename+" | DatasetID: "+dataset.datasetid);
	}

	function handleResult(err, result){
		topic.publish("diagrammer/HideStandby");

		if(err){
			console.log("Error with request");
			return;
		}

		if ( !result.data ){
			console.log("Response has no data");
			return;
		} else {
			var dataset = result.data[0];//.response;
		}

		updateChartTitle(dataset);

		processData(dataset,function(){
			//processData callback
			//set values
				setVariableUnit();
				setDefaultChartType();

				updateYAxisFilteringSelect();
				//set yscale
				setYLookupFunction(metadata.yaxisdomainname);//or with defChronolgyID get defChronologyName
				
								
				updateVariableUnitFilteringSelect(metadata.allvarunits);
				//set var. unit fs
				updateVariableUnitUI();

				prepareUI(function(){
					


					//create renderObjects
					taxaRenderObjects = createTaxaObjectsToRenderAsChart(metadata.variableunit);
					
					//prepareUI callback
					sortedtaxaRenderObjects = sortFilterData(taxaRenderObjects);
					//renderData();
					renderNewData(sortedtaxaRenderObjects);

					initialized = true;
				});
		});
		//prepareUI();
		//renderData(taxaRenderObjects);
	}

	function updateChart(){
		//case#1: VariableUnit changes
		taxaRenderObjects = createTaxaObjectsToRenderAsChart(metadata.variableunit);
		
		//prepareUI callback
		sortedtaxaRenderObjects = sortFilterData(taxaRenderObjects);
		//renderData();
		renderNewData(sortedtaxaRenderObjects);
	}

	

	//programmatically update Var.Unit UI
	function updateVariableUnitUI(){
		if(metadata.variableunit){
			//prevent handler from reponsding to FS change event
			handlerChangeVariableUnit.remove();
			require(["dijit/registry","dojo/on"],function(registry,on){
				var fsVU = registry.byId("fsVariableUnits");
				fsVU.set("value",metadata.variableunit);

				//enable fs change handler
				handlerChangeVariableUnit = on(fsVU, "change", handleVariableUnitChange);

			})
		}
	}


	function updateYAxisFilteringSelect(){
		require(["dojo/store/Memory", "dijit/registry", "dojo/on"],function(Memory, registry,on){

			//get filteringselect
			var yaxisfs = registry.byId("fsSelectYAxis");
			//selection store
			var ageDepthStore = [];

			ageCollection.forEach(function(d){
				if(!d.validage){
					//omit from fs; can't use
					return;
				}
				var storeObj = {};
				storeObj.chronologyid = d.chronologyid;
				storeObj.domainname = d.chronologyname;
				storeObj.unittype = "Age";
				ageDepthStore.push(storeObj);
			})

			//create depth store object if Depth values exist
			//some fauna have no depth
			if(metadata.depthcollection.depthextent[0]){
				var storeObj = {};
				storeObj.chronologyid = null;
				storeObj.domainname = "Depth";
				storeObj.unittype = "Depth";
				ageDepthStore.push(storeObj);
			}

			//update memory with newly created ageCollection
			
			yAxisStore = new Memory({data: ageDepthStore, idProperty: "domainname"});

			yaxisfs.set("store", yAxisStore);


        })
	}

	function setMetaData(property, value){
		metadata[property] = value;
	}

	function clearMetaData(){
		//clear all references
		metadata = {};
	}


	

	//define valid pollen EcolGroupIDs
	function pollenEcolGroupIDFilter(dataset){
		//TO DO: take user input for ecolgroupids
		var includeEcolGroupIDs = ["TRSH","UPHE","VACR"];
		var filteredDataset = [];
		var filteredSamples = [];
		
		var filteredSamples = dataset.samples;

		filteredSamples.forEach(function(d){
			var filteredSampleData = [];
			filteredSampleData = d.sampledata.filter(function(e){
				return includeEcolGroupIDs.indexOf(e.ecolgroupid) > -1;
			})
			d.sampledata = filteredSampleData;

		});

		//variables byRef so can simpley return dataset as altered object; filteredSamples and dataset.Samples reference the same object
		filteredDataset = dataset;

		filteredDataset.samples = filteredSamples;



		return filteredDataset;
	}

	function processData(dataset,callback){
		/**get useful dataset metadata
		* dataset.DatasetID: id
		* dataset.DefChronologyID: default chronologyid
		* dataset.DOI
		* dataset.Site.SiteName
		* dataset.Site.SiteID
		* dataset.DatasetType
		*/
		metadata = {};
		metadata.datasettype = dataset.datasettype;
		metadata.charttypeselection = "FilledArea";
		metadata.yaxisdomainname = null;
		metadata.yaxislabel = null;
		metadata.yaxisunittype = null;
		metadata.yaxisdomainextent = [];
		metadata.yaxisagelookupfunction = null;
		metadata.currenttopx = 10;
		setMetaData("defchronologyid", dataset.defchronologyid);
		//metadata.DefChrongologyID = dataset.DefChronologyID;

		//filter for EcolGroupID(s) of interest
		switch(metadata.datasettype){
			case "pollen":
				//currently include only UPHE, TRSH, VACR
				dataset = pollenEcolGroupIDFilter(dataset);
				break;
			case "ostracode":
				//no EcolGroupID filter
				break;
			case "vertebrate fauna":
				//no EcolGroupID filter
				break;
			case "diatom":
				//no EcolGroupID filter
				break;
		}
		

		//get set of unique SampleID values
		var SampleIDs = d3.set(dataset.samples, function(d){
			return "s"+d.sampleid;
		}).values();

		//create map of SampleID, Depth
		var sampleDepths;
		sampleDepths = d3.map();
		dataset.samples.forEach(function(d){
			sampleDepths.set("s"+d.sampleid, d.analysisunitdepth);
		});
		var depthExtent;
		depthExtent = d3.extent(sampleDepths.values());
		var depthCollection = {};
    	depthCollection.depthextent = depthExtent;
    	depthCollection.depthlookup = sampleDepths;
    	depthCollection.units = "cm";
    	metadata.depthcollection = depthCollection;

		//create ageCollection of SampleID, Age maps for each chronology
		ageCollection = [];
		dataset.samples[0].sampleages.forEach(function(d){
			var ageObj = {};
			ageObj.agetype = d.agetype;
			ageObj.chronologyid = d.chronologyid;
			ageObj.chronologyname = d.chronologyname;
			ageObj.ageextent = [];
			ageObj.agelookup = d3.map();
			ageCollection.push(ageObj);
		});

		
		//extract and concatenate SampleData object arrays into sampleData
		//{}8 properties: TaxonName, VariableUnits, VariableElement, VariableContext, TaxaGroup, Value, EcolGroupID, + SampleID
		sampleData = [];
		var ageData = [];
		dataset.samples.forEach(function(d,i){
			var theSampleID = "s"+d.sampleid;

			d.sampledata.forEach(function(e,j){
				e.sampleid = theSampleID;
			})
			d.sampleages.forEach(function(f,k){
				f.sampleid = theSampleID;
			})
			sampleData = sampleData.concat(d.sampledata);
			ageData = ageData.concat(d.sampleages);
		})

		//extract unique values for VariableUnits, TaxonName, EcolGroupID 
		var allVarUnits = [];
		allVarUnits = d3.set(sampleData,function(d){return d.variableunits}).values();
		metadata.allvarunits = allVarUnits;

		/**Set Defaults: round 1 
		variableUnit, chartType, topX, genusGrouping
		**/
		//set default variableUnit
		//setVariableUnit();
		//setDefaultChartType();

		var allTaxaNames = [];
		allTaxaNames = d3.set(sampleData,function(d){return d.taxonname}).values();
		metadata.alltaxanames = allTaxaNames; 

		metadata.allecolgroupids = d3.set(sampleData,function(d){return d.ecolgroupid}).values();

		//all possible y axis scales {Depth, ChronID#1, ChronID#2, ...}
		ageCollection.forEach(function(d){
			var theAge = d.chronologyid;
			var sampleAges = d3.map();
			var currentAgeData = ageData.filter(function(e){
				return e.chronologyid = theAge;
			})
			currentAgeData.forEach(function(f){
				//sampleAges.set(d.SampleID, d.Age);
				//test vertebrate fauna w/ only youngestAge, oldestAge
				var ageObj = {};
				ageObj.ageyounger = f.ageyounger;
				ageObj.age = f.age;
				ageObj.ageolder = f.ageolder;
				ageObj.agemean = null;
				if(f.ageyounger != NaN && f.ageolder != NaN){
					ageObj.agemean = (f.ageyounger + f.ageolder)/2;
				}
			
				sampleAges.set(f.sampleid, ageObj);
			});
			//any of the age values may be null
			var arrAllAgeValues = [];
			
			sampleAges.each(function(g){
				arrAllAgeValues.push(g.ageyounger);
				arrAllAgeValues.push(g.age);
				arrAllAgeValues.push(g.ageolder);
			})
			var ageExtent = d3.extent(arrAllAgeValues);
			
			d.agelookup = sampleAges;
			d.ageextent = ageExtent;

			//test always true
			d.validage = true;
			//validate AgeExtent
			if ((d.ageextent[1] - d.ageextent[0]) >= 0){
				d.validage = true
			} 

			if (d.ageextent[0] == null || d.ageextent[1] == null){
				d.validage = false;
			}
		})

		metadata.agecollection = ageCollection;

		//set initial yLookupFunction
		if(metadata.agecollection[0].ValidAge){
			metadata.yaxisagelookupfunction = metadata.agecollection[0].agelookup;
			metadata.yaxisdomainname = metadata.agecollection[0].chronologyname;
			metadata.yaxisunittype = "Age";
		} else {
			metadata.yaxisagelookupfunction = metadata.depthcollection.depthlookup;
			metadata.yaxisdomainname = "Depth";
			metadata.yaxisunittype = "Depth";
		}

		//todo add getter/setter for ageCollection
		//updateYAxisFilteringSelect();
		//updateVariableUnitFilteringSelect(allVarUnits);


		//get summary stats by SampleID for topX selection, abundance calculation
		var dataBySampleID = d3.nest()
			.key(function(d){
				return d.sampleid;
			})
			.key(function(d){
				return d.variableunits;
			})
			//.rollup(function(values){
			//	return {
			//		totalCount: d3.sum(values, function(d){ return d.value})
			//}
			//})
			.map(sampleData);

		summaryDataBySampleID = d3.nest()
			.key(function(d){
				return d.sampleid;
			})
			.key(function(d){
				return d.variableunits;
			})
			.rollup(function(values){
				var currentKey = values[0].variableunits;//JSON.stringify(values);
				switch(currentKey){
					case "NISP":
						return {
							sumnisp: d3.sum(values, function(d){ return d.value}),
							counttaxa: values.length
						}
						break;
					case "valves/g":
						return {
						meanconcentration: d3.mean(values, function(d){ return d.value})
						}
						break;
					case "MNI":
						return {
							summni: d3.sum(values, function(d){ return d.value})
						}
						break;
					case "present/absent":
						return {
							counttaxa: values.length
						}
						break;
					default:
						return {
							counttaxa: values.length
						}
						break;
				}
			})
			.map(sampleData);

		//taxaRenderObjects = createTaxaObjectsToRenderAsChart(metadata.variableUnit);

		callback();
		
	}

	function sortFilterData(srcTaxaRenderObjects){
		//sort taxa value collections by abundance
		abundTaxaRenderObjects = srcTaxaRenderObjects.sort(sortAbundanceDesc);

		//then by Age within taxa value collections if not showing depth
		if(metadata.yaxisunittype == "Age"){
			abundTaxaRenderObjects.forEach(function(d){
				var vals = d.values;
				var sortedValues = vals.sort(sortByAgeYounger);
				d.values = sortedValues;
			})
		}

		var topXtaxaRenderObjects = filterForTopX(abundTaxaRenderObjects, metadata.currenttopx);
		//createEcolGroupRenderObjects()
		var bottomNtaxaRenderObjects = filterForBottomN(abundTaxaRenderObjects, metadata.currenttopx);
		//group bottomN by EcolGroupID
		//see Line 655
		//var groupedTaxa = groupByEcolGroupID(bottomNtaxaRenderObjects, "NISP");
		var groupedTaxa = groupByEcolGroupID(bottomNtaxaRenderObjects, metadata.variableunit);

		var sortedtaxaRenderObjects = topXtaxaRenderObjects.sort(sortEcolGroupThenTaxonName);	
		//append grouped data to taxa data
		var aggregatedRenderObjects = sortedtaxaRenderObjects.concat(groupedTaxa);

		return aggregatedRenderObjects;
	}

	function renderDataOld(){
		sortedtaxaRenderObjects.forEach(function(d,i){
			constructChart(d,i);
		});
	}

	function sortSampleID(a,b){
		var x = +a.sampleid.substr(1,a.sampleid.length);
        var y = +b.sampleid.substr(1,b.sampleid.length);
        return x - y;
	}

	function sortByAgeYounger(a,b){
		//get AgeYounger
		var x = lookupYValueBySampleID(a.sampleid);
		var y = lookupYValueBySampleID(b.sampleid);

        return x - y;
	}

	//sort by maxAbundance
	function sortAbundanceDesc(a,b){
        var x = a.maxabundance;
        var y = b.maxabundance;
        return x < y ? 1 : x > y ? -1 : 0;
    }
	//get key: , maxAbundance

	//filter for TopX
	function filterForTopX(theArray,x){
		var result = theArray.filter(function(d,i){
			return i < x;
		})
		return result;
	}

	function filterForBottomN(theArray, x){
		var result = theArray.filter(function(d,i){
			return i >= x;
		})
		return result;
	}
	
	//sort again by EcolGroupID, then TaxonName
	function sortEcolGroupThenTaxonName(a,b){
        if(a.ecolgroupid == b.ecolgroupid){
            var x = a.key;
            var y = b.key;

            return x < y ? -1 : x > y ? 1 : 0;
        }
        var x = a.ecolgroupid;
        var y = b.ecolgroupid;
        return x < y ? -1 : x > y ? 1 : 0;
    }

    function groupByEcolGroupID(theArray, variableUnit){
    	//for each allEcolGrooupIDs[]
    	var ecoGrpRenderObjects = [];
    	metadata.allecolgroupids.forEach(function(d){
    		var obj = {};
    		obj.ecolgroupid = d;
    		obj.values = [];
    		ecoGrpRenderObjects.push(obj); 
    	});

    	//for each groupID, get all samples, aggregate by SampleID
    	ecoGrpRenderObjects.forEach(function(d){
    		var filteredByEcoGrp = theArray.filter(function(e){
    			return e.ecolgroupid === d.ecolgroupid;
    		})
    		//append all values objects to EcolGroup collection
    		filteredByEcoGrp.forEach(function(f){
    			//concatenate arr of objects
    			var tmpArr = d.values.concat(f.values);
    			//replace with result of concatenation
    			d.values = tmpArr;
    		})
    		
    	});

    	//now sum values
    	//want:
    	/**{}
    	.EcolGroupID
    	.key
    	.maxAbundance
    	.values:[]
	    	.EcolGroupID
			.SampleID
			.Value
			.VariableUnits
			.Abundance

		//have:
		.EcolGroupID
		.values[]

    	**/

    	//for leftover taxa not in top group
    	//aggregate values by SampleID by EcolGroupID
    	ecoGrpRenderObjects.forEach(function(d){
    		//for each EcolGroupID, total values by SampleID across all taxa
    		var nest = d3.nest().key(function(e){ 
    			return e.sampleid })
    		.rollup(function(values){
    			return { 
    				//sum of values across taxa within shared EcolGroupID at SampleID
    				totalValue: d3.sum(values, function(f){
    					return f.value})
    			}
    		})
    		.map(d.values);
    		
    		//for each EcolGroupID, generate a display object aggregating properties for each SampleID	 
    		d.key = "Other "+d.ecolgroupid;
    		d.values = [];
    		nest.each(function(value, key){
    			var obj = {}
    			obj.sampleid = key;
    			//compare to value at SampleID in summaryDataBySampleID
    			var sampleAggregate = getSampleAggregateByVariableUnit(key,value.totalValue);
    			if(sampleAggregate){
    				obj.value = sampleAggregate;
    			} else {
    				obj.value = null;
    			}    			
    			obj.ecolgroupid = d.ecolgroupid;
    			d.values.push(obj);
    		});

    	})

    	//create EcolGroupID lengend objects
    	createLegend(ecoGrpRenderObjects);

    	

    	//now calc relative abundance
    	ecoGrpRenderObjects.forEach(function(d){
    		d.values.forEach(function(e){
	    		e.abundance = (e.value/summaryDataBySampleID.get(e.sampleid).get(variableUnit).sumnisp)*100;
    		})
    		var abundanceExtent = d3.extent(d.values,function(f){
    			return f.abundance;
    		});
    		var valueExtent = d3.extent(d.values, function(f){
    			return f.value;
    		})
    		if(abundanceExtent){
    			d.maxabundance = abundanceExtent[1];
    		} else {
    			console.log("Error calculating maxAbundance");
    			d.maxabundance = 0;
    		}
    		if(valueExtent){
    			d.maxvalue = valueExtent[1];
    		} else {
    			console.log("Error calculating maxValue");
    			d.maxvalue = 0;
    		}
    	})

    	//drop objects with no data
    	var nonNullEcoGrpRenderObjects = ecoGrpRenderObjects.filter(function(d){
    		return d.values.length > 0;
    	})

    	//insure samples are sorted ascending
    	//if Vertebrate Fauna, order by AgeYounger-- samples are not in chronological order
    	if(metadata.datasetType == "vertebrate fauna"){
    		//order by age, not sampleid
			nonNullEcoGrpRenderObjects.forEach(function(d){
	    		d.values = d.values.sort(sortByAgeYounger);
	    	})
    	} else {

			nonNullEcoGrpRenderObjects.forEach(function(d){
	    		d.values = d.values.sort(sortSampleID);
	    	})
		}

    	return nonNullEcoGrpRenderObjects;
    }

    //given current VariableUnit, how should EcolGroupID aggregated sample values be presented?
    function getSampleAggregateByVariableUnit(sampleid, value){
    	var currentVariableUnit = metadata.variableunit;
    	var aggValue = null;
    	switch(currentVariableUnit){
    		case "NISP":
    			if(summaryDataBySampleID.get(sampleid).get(currentVariableUnit).sumnisp > 0){
    				aggValue = (value/summaryDataBySampleID.get(sampleid).get(currentVariableUnit).sumnisp) * 100;
    			}
    			break;
    		case "MNI":
    		    aggValue = value;//summaryDataBySampleID.get(sampleid).get(currentVariableUnit).summni;
    		    break;
    		case "present/absent":
    			aggValue = value;//summaryDataBySampleID.get(sampleid).get(currentVariableUnit).present;
    		    break;
    		default:
    			console.log("Error returning aggregate value for variable unit/sampleid/ecolgroupid");
    			break;
    	}
    	
    	return aggValue;
    }


    var symbolRenderer = d3.symbol().size(32).type(d3.symbolCross);
    /*
    var symbolRenderer = function(){
    	var symFunc;
    	//placeholder for cases to be defined
    	symFunc =  d3.symbol().size(32).type(d3.symbolTriangle); 
    	//symFunc =  d3.symbol().size(32).type(d3.symbolCross); 
    	return symFunc;
    }
    */

	//function will generate collection of objects to render
	//for each Taxa by chosen VariableUnit
	function createTaxaObjectsToRenderAsChart(variableUnit){
		//for each VariableUnit
		//create dataByTaxaToRender
		/*
			1. group by taxonname
			2. calc abundance value
		*/
		var varUnitFilteredSamples = sampleData.filter(function(d){
			return d.variableunits == variableUnit;
		})

		var filteredTaxaRenderObjects = d3.nest()
			.key(function(d){
				return d.taxonname
			})
			.entries(varUnitFilteredSamples);

		switch(variableUnit){
			//if NISP, need to calculate abundance values
			case "NISP":
				filteredTaxaRenderObjects.forEach(function(d){
					//calc maxAbundance for Taxon
					d.maxabundance = 0;
					//pass EcolGroupID to container
					d.ecolgroupid = d.values[0].ecolgroupid;
					d.values.forEach(function(e){
						var abundance = (e.value / summaryDataBySampleID.get(e.sampleid).get(variableUnit).sumnisp)*100;
						e.abundance = abundance;
						e.nispcount = e.value;
						d.maxabundance < abundance ? d.maxabundance = abundance : d.maxabundance = d.maxabundance;
						//track a maxValue for all numeric VariableUnits
						d.maxvalue = d.maxabundance;
					})
				})
				break;
			case "MNI":
				filteredTaxaRenderObjects.forEach(function(d){
					//calc maxAbundance for Taxon
					d.countmni = 0;
					//pass EcolGroupID to container
					d.ecolgroupid = d.values[0].ecolgroupid;
					d.values.forEach(function(e){
						var mni = summaryDataBySampleID.get(e.sampleid).get(variableUnit).summni;
						//track a maxValue for all numeric VariableUnits
						d.maxmni < mni ? d.maxmni = mni : d.maxmni = d.maxmni;
						d.maxvalue = mni;

					})
					
				})
				break;	
			default:
				filteredTaxaRenderObjects.forEach(function(d){
					//pass EcolGroupID to container
					d.ecolgroupid = d.values[0].ecolgroupid;
				})
				break;
		}

		return filteredTaxaRenderObjects;


	}

	
	//change genus grouping -->
	function updateGenusGrouping(arrGenusNames){
		/*
		1.copy sampleData collection
		2.for each value in arrGenusNames, replace matched TaxonName genus with group alias
		3.copy allTaxonNames and replace appropriate names with grouping alias
		4.generate new taxaObjectsToRender
		5.sort
		6.filter for topX
		7.updateChart
		*/
	}

	//change VariableUnit -->
	function updateVariableUnitSelection(varUnit){
		/*
		1. generate new taxaObjectsToRender
		2. sort
		3. filter for topX
		4. updateChart
		*/
	}
	
	//sort data for display
	function sortByEcolGroupAndTaxa(){
		/* sort first by EcolGroup (assigned ordering)
		then TaxonName (alphabetical)
		*/
	}


	function setScales(){
		if( metadata.yaxisunittype == "Depth"){
			strataYScale.domain(metadata.depthCollection.depthextent);
		} else {

			var currentAge = ageCollection.filter(function(d){
				return d.chronologyname == metadata.yaxisdomainname;
			})

			if(currentAge.length > 0){
				var currentAgeExtent = currentAge[0].ageextent;
				strataYScale.domain(currentAgeExtent);
			}
		}
		
	}

	function setAxes() {
        // adundAxis
        abundAxisBottom = d3.axisBottom(strataXScale)
          .tickPadding([6])
          .tickSizeInner([6])
          .tickSizeOuter([10])
          .tickFormat(d3.round);

        // adundAxisTop
        abundAxisTop = d3.axisTop(strataXScale)
          .tickPadding([10])
          .tickSizeInner([6])
          .tickSizeOuter([12]);

        // yAxis
        yAxis = d3.axisLeft(strataYScale)
          .tickSizeInner([3])
          .tickSizeOuter([6])
          .tickPadding([8]);
    }

    function updateYAxisLabel(){
    	/*
    	require(["dijit/registry"],function(registry){
    		//get yAxisDomain selection
    		var fsYDomain = registry.byId("fsSelectYAxis");
	    	var yDomainStore = fsYDomain.get("store");
	    	var yDomainName = fsYDomain.get("value");
	    	var domainObj = yDomainStore.get(yDomainName);
	    	var label = domainObj.UnitType;
		*/
	    	var label = metadata.yaxislabel;


		    //add y-axis label
		    var yAxisLabel = d3.select(".y-axis-label");
		    if(!yAxisLabel.empty()){
		    	//get yAxisDomain selection
		    	yAxisLabel.html = label;

		    } else {

		    	var firstChart = d3.select(".charts .taxa-chart")      
		        //.insert("text","text")
			        .append("text")
			        .attr("class","y-axis-label")
			        .attr("x", 30)
			        .attr("y", 145)
			        .attr("transform",function(d,i){          
			          //return "rotate(-90 0,150)";    
			          return "rotate(-90 25,150)";
				    })
			        .text(label);
		    }    
	   // })    
    }

    function prepareUI(callback) {
    	try{
    		require(["dijit/registry"],function(registry){
	        // set strata scales
	        strataYScale = d3.scaleLinear().range([0, height]);
	        strataXScale = d3.scaleLinear().range([0, width]);

	        //set default YAxis values
	        //precedence: 1) has DefaultChronID, 2) has Depth, 3) first ageCollection member 

	        if(metadata.defchronologyid){
	        	var defaultAge = ageCollection.filter(function(d){
	        		return d.chronologyid == metadata.defchronologyid;
	        	});
	        	metadata.defchronologyname = defaultAge[0].chronologyname;
	        	
	        	//update demo control selection
	        	var fsYAxisDomain = registry.byId("fsSelectYAxis");
	        	var fsYAxisDomainStore = fsYAxisDomain.get("store");
	        	var storeObj = fsYAxisDomainStore.get(defaultAge[0].chronologyname);
	        	if(storeObj){
	        		setYAxisDomain(storeObj.domainname);
	        		fsYAxisDomain.set("value", storeObj.domainname);
	        	}
	        	
	        	//may have null depthCollection values
	        } else if (metadata.depthCollection.depthextent[0]) {
	        	console.log("setting default Y Axis domain as Depth")
	        	//update demo control selection
	        	var fsYAxisDomain = registry.byId("fsSelectYAxis");
	        	var fsYAxisDomainStore = fsYAxisDomain.get("store");
	        	var storeObj = fsYAxisDomainStore.get("Depth");
	        	if(storeObj){
	        		setYAxisDomain("Depth");
	        		fsYAxisDomain.set("value", "Depth");
	        	}
	    	}

	    	
	        /// update scales
	        setScales();

	        // set axes
	        setAxes();

	        // set taxalines
	        /*
	        taxaline = d3.line()
	          .x(function (d) {
	              return strataXScale(d.Abundance);
	          })
	          .y(function (d) {
	              //return strataYScale(d.depth); 
	              var depth;
	              //depth = strataYScale(lookupYValueBySampleID(d.SampleID));
	              depth = strataYScale(this.lookupYValueBySampleID(d.SampleID));
	              return depth;

	          });
			
	        taxaline5x = d3.line()
	          .x(function (d) {
	              return strataXScale(d.Abundance * 5); 
	          })
	          .y(function(d) { 
	              //return strataYScale(d.depth);
	              var depth;
	              //depth = strataYScale(lookupYValueBySampleID(d.SampleID));
	              depth = strataYScale(this.lookupYValueBySampleID(d.SampleID));
	              return depth;

	          });
	        */

	        taxaline5x = d3.line()
	          .defined(function(d){ return d;})
	          .x(function (d) {
	              return strataXScale(d[metadata.xscaleinput] * 5); 
	          })
	          .y(function(d) { 
	              //return strataYScale(d.depth);
	              var depth;
	              //depth = strataYScale(lookupYValueBySampleID(d.SampleID));
	              depth = strataYScale(lookupYValueBySampleID(d.sampleid));
	              return depth;

	          });

	        taxaline = d3.line()
	        	.defined(function(d){ return d;})
	        	.x(function(d){
	        		return strataXScale(d[metadata.xscaleinput]);
	        	})
	        	.y(function(d){
	        		var depth;
	              //depth = strataYScale(lookupYValueBySampleID(d.SampleID));
	              //console.log(d.TaxonName +"|"+d.SampleID +" | " + lookupYValueBySampleID(d.SampleID) +" | " + strataYScale(lookupYValueBySampleID(d.SampleID)) );
	              depth = strataYScale(lookupYValueBySampleID(d.sampleid));
	              return depth;
	        	})

	        
	        taxaarea = d3.area()
				    .defined(taxaline.defined())
				    .x1(taxaline.x())
				    .y(taxaline.y())
				    .x0(strataXScale(0));

			taxaarea5x = d3.area()
				    .defined(taxaline5x.defined())
				    .x1(taxaline5x.x())
				    .y(taxaline5x.y())
				    .x0(strataXScale(0));

			callback();

	         /*
			DRAW AREA
				var x = d3.scaleLinear()
		    	.range([0, width]);

				var y = d3.scaleLinear()
				    .range([height, 0]);

				var line = d3.line()
				    .defined(function(d) { return d; })
				    .x(function(d) { return x(d.x); })
				    .y(function(d) { return y(d.y); });

				var area = d3.area()
				    .defined(line.defined())
				    .x(line.x())
				    .y1(line.y())
				    .y0(y(0));
	         */

	        // set diagrammer reference
	        //diagrammer = this;

	        /*
		        topic.subscribe("diagrammer/ChronologyChange",function(evt){
		            console.log("diagrammer/ChronologyChange evt handled");
		            handleYAxisChange(evt);
		        });
			*/
			})
		} catch(e){
			console.log("Error in stratigraphic-api-plot function prepareUI " + e );
		}
    }

    function getCurrentChronologyName(){
    	return currentChronologyName;
    }

    function setInitialChronologyName(value){
    	currentChronologyName = value;
		//dispatch update event
		setYLookupFunction(value)
    }



    //expects yAxis domain object
    function setYAxisDomain(value){
    	//had yaxis domain changed
    	//if( metadata.yAxisDomainName != value ){
    		//y axis is depth
    		if (value == "Depth"){
	        	metadata.yaxislabel = "cm";
	        	metadata.yaxisunittype = "Depth";
	        	metadata.yaxisdomainname = "Depth";
	        	metadata.yaxisdomainextent = metadata.depthcollection.depthextent;//depthExtent;
	        	metadata.yaxisdepthlookupfunction = metadata.depthcollection.depthlookup;//sampleDepths;
	        	//metadata.yAxisAgeLookupFunction = null;
    		} else 
    		//y axis is age
    		{
    			var selectedAge = ageCollection.filter(function(d){
    				return d.chronologyname == value;
    			})
    			var ageObj = selectedAge[0];
    			metadata.yaxislabel = ageObj.agetype;
	        	metadata.yaxisunittype = "Age";
	        	metadata.yaxisdomainname = ageObj.chronologyname;
	        	metadata.yaxisdomainextent = ageObj.ageextent;
	        	//metadata.yAxisDepthLookupFunction = null;
	        	metadata.yaxisagelookupfunction = ageObj.agelookup;
    		}

    		//set yAxis lookup function
    		setYLookupFunction(value);
    		
    		//check if charts exist
    		var numberOfCharts = d3.selectAll(".taxa-group").size();
    		if(numberOfCharts){
    			updateCharts();
    		}
    	//}
    }

    function setYLookupFunction(value){
    	if(value == "Depth"){
    		metadata.yaxislookupfunction = metadata.yaxisdepthlookupfunction;
    	} else {
    		metadata.yaxislookupfunction = metadata.yaxisagelookupfunction;
    	}
    	
    }

    function setCurrentTopX(value){
    	currentTopX = value;
    	metadata.currenttopx = value;
    }

    
    //if Age lookup and no Age value, use MeanAge
    function lookupYValueBySampleID(SampleID){
    	//if age map, values are age objects w/ younger, age, older values
    	if(metadata.yaxisdomainname == "Depth"){
    		return metadata.yaxislookupfunction.get(SampleID);
    	} else {

	    	var ageObj = metadata.yaxislookupfunction.get(SampleID);
	    	var returnValue;
	    	if(ageObj.age){
	    		returnValue = ageObj.age;
	    	} else {
	    		//ageObj.AgeYounger != null ? returnValue = ageObj.AgeYounger : returnValue = 0;
	    		returnValue = ageObj.agemean;
	    	}
			return returnValue;
		}
    }

    function renderDataOld(){
		sortedtaxaRenderObjects.forEach(function(d,i){
			constructChart(d,i);
		});
	}

	function getCleanTaxonName(name){
		var cleanName;
		//replace space, period, forward slash
        var cleanName = name.replace(/[\s]|[.]|[/]/g,"-");
        //replace parentheses
        var cleanName = cleanName.replace(/[()]/g,"_");
		return cleanName;
	}

	function calcChartRange(maxValue){
		//allows scaling all chart widths to pixels allotted for every
		//5 units of measure 
		
		var range = [0]; 
		if(maxValue){
			var intervals = Math.ceil(maxValue/5);
			var taxonChartWidth = chartIntervalWidth * intervals;
			range.push(taxonChartWidth);
		} else {
			//define fixedWith as global var; see calcChartWidth
			range.push(fixedWidth)
		}
		return range;
	}

	function calcChartWidth(maxValue, variableUnit){
		/*handle multiple VariableUnit types
		Cases:
		NISP - scale 5 unit intervals
		MNI - scale 5 unit intervals
		present/absent - fixed width
		valves/g - scale 5 unit intervals
		*/

		switch(variableUnit){
			case "present/absent":
				var taxonChartWidth = fixedWidth;
				break;
			//covers NISP, MNI, valves/g
			default:
				//allows scaling all chart widths to pixels allotted for every
				//5 units of measure  
				var intervals = Math.ceil(maxValue/5);
				var taxonChartWidth = chartIntervalWidth * intervals;
				
				break;
		}

		return taxonChartWidth;
		
	}

	function calcChartDomain(maxValue){
		//calc range rounding up to 5 unit increments
		var domain = [0];
		if(maxValue){
			var intervals = Math.ceil(maxValue/5);
			var maxValue = 5 * intervals;
			domain.push(maxValue);
		} else {
			//present/absent
			domain.push(1);
		}
		return domain;
	}

	function calcTickMarks(intervals){
		var chartTickValues = [];
        for (var j=2;j <= intervals; j+=2){
            chartTickValues.push(j*5);
        }
        return chartTickValues;
	}

	function getCurrentVariableUnits(){
		return "NISP";
	}

	function renderNewData(renderObjects){
		//remove all charts
		var filteredCharts = d3.select(".charts")
			.selectAll(".taxa-group")
			.remove();
		var axislabel = d3.select(".x-axis-label").remove();


		//data join and create
		var chartDivs = d3.select(".charts").selectAll(".taxa-group")
			.data(renderObjects,function(d){
				//TaxonName as key value
				return d.key;
			})
			.enter()
			.append("div")
			.attr("class",function(d){
				var className = getCleanTaxonName(d.key);
				return "taxa-group " +className;
			})
			.style("width", function(d, i){
				//generalize: all measures --> maxValue (instead of d.maxAbundance)
				var taxonChartWidth = calcChartWidth(d.maxvalue, metadata.variableunit);
				//omit margin for y-axis if not first chart
				if(i === 0){
				  return taxonChartWidth + margin.left + chartGapRight+"px"; //+ margin.right;
				} else {
				  return taxonChartWidth + chartGapRight + "px";
				}
            }
        );

		var xAxisLabel = d3.select(".charts").append("div")
			.attr("class","x-axis-label")
			.html(function(d){
				//var variableUnits = getCurrentVariableUnits();
				var variableUnit = metadata.variableunit;
				var label;
				switch(variableUnit){
					case "NISP":
						label = "Abundance (%)";
						break;
					case "valves/g":
						label = "Concentration (valves/g)";
						break;
					case "presence":
						label = "Taxon Present";
						break;
					default:
						label = variableUnit;	
				}
				return label;
		})

		var longLabels = chartDivs.append("svg")
			.attr("class", function(d){
				var className = getCleanTaxonName(d.key);
				return className + " full-label";
			})
			.attr("width", 200)
            .attr("height", longLabelHeight)
            .append("g")
            .attr("transform",function(d,i){
              if(i === 0){
                return "translate(" + margin.left + "," + margin.top + ")"
              } else {
				return "translate(0," + margin.top + ")"
              }         
	        })
	        .append("text")
	        .attr("x", 10)
	        .attr("y",longLabelHeight - margin.top)
	        .attr("transform","rotate(-45 10,135)")
	        .text(function(d,i){
	        	return d.key;
	        })
            .on("mouseout", function(d){
	              //hideToolTip();
	        })
            .on("mouseover",function(d){
	              //showToolTip();
	        });


			/**** Taxa Chart ****/
			var chartComponents = chartDivs.append("svg")	
				.attr("class", function(d){
					var className = getCleanTaxonName(d.key);
					return className + " taxa-chart";
				})
				.attr("width", function(d, i){
					  var taxonChartWidth = calcChartWidth(d.maxvalue, metadata.variableunit);
					  //omit margin for y-axis if not first chart
	                  if(i === 0){
	                      return taxonChartWidth + margin.left + chartGapRight; //+ margin.right;
	                  } else {
	                      return taxonChartWidth + chartGapRight;
	                  }
	              })
	            .attr("height", height + margin.top + margin.bottom)
	            .append("g")
	            .attr("transform",function(d,i){
	                  if(i === 0){
	                      return "translate(" + margin.left + "," + margin.top + ")"
	                  } else {
	                      //return "translate(" + chartGapLeft + "," + margin.top + ")"
	                      return "translate(0," + margin.top + ")"
	                  }         
	              })
	              .on("mouseout", function(d){
	                  hidePoints();
	              })
	              .on("mouseover",function(d){
	                  showPoints();
	              });
	            
	            

	        var taxaGroup = chartComponents.append("g")
	                .attr("class", "g-taxa-group")
	                .style("width", function(d){
	                    var taxonChartWidth = calcChartWidth(d.maxvalue, metadata.variableunit);
	                    return taxonChartWidth;
	                });

	        

	        var clipRect = taxaGroup.append("clipPath")
		          .attr("id",function(d){
		          	 return "clip-"+getCleanTaxonName(d.key);
		      	   })
		          .append("rect")
		          .attr("x",0)
		          .attr("y", 0)
		          .attr("width", function(d){
		          	return calcChartWidth(d.maxvalue, metadata.variableunit);
		          })
		          .attr("height", height)  

	/** 5x Area Chart **/
	if(metadata.charttypeselection == "FilledArea"){
	        var exagPaths = taxaGroup.append("path")
	                .attr("clip-path",function(d){
	                	return "url(#clip-"+getCleanTaxonName(d.key)+")";
	            	})
	                .attr("class", function(d) { 
	                    return d.ecolgroupid + " exaggerate-5x area";
	                })
	                .attr("d", function (d) {
	                	strataXScale.range(calcChartRange(d.maxabundance));
	          	  		strataXScale.domain(calcChartDomain(d.maxabundance));
	                	return taxaarea5x(d.values);
	                })
	                .style("fill",function(d,i){
			          	//only vertebrate fauna are styled here, the rest use CSS
	          			if(metadata.datasettype == "vertebrate fauna"){
				          	if(d.ecolgroupid && metadata.allecolgroupids){
				          		return colors20(metadata.allecolgroupids.indexOf(d.ecolgroupid));
				          	} else {
				          		return '#dddddd';
			          		}
			          	} else {
			          		return null;
			          	}
	          		})
	          		.style("fill-opacity", 0.5); 

	/** Standard Scale Area Chart*/
	       
	        var paths = taxaGroup.append("path")
	                .attr("class", function(d) { 
	                    return d.ecolgroupid + " standard-scale area";
	                })
	                .attr("d", function(d) {
	                	//strataXScale.range(calcChartRange(d.maxAbundance));
	          	  		//strataXScale.domain(calcChartDomain(d.maxAbundance));
	                	//return taxaarea(d.values);
	                	strataXScale.range(calcChartRange(d.maxvalue));
		          	  	strataXScale.domain(calcChartDomain(d.maxvalue));
	                	return taxaarea(d.values); 
	                })
	                .style("fill",function(d,i){
	                	//only vertebrate fauna are styled here, the rest use CSS
	          			if(metadata.datasettype == "vertebrate fauna"){
				          	if(d.ecolgroupid && metadata.allecolgroupids){
				          		return colors20(metadata.allecolgroupids.indexOf(d.ecolgroupid));
				          	} else {
				          		return '#dddddd';
			          		}
			          	} else {
			          		return null;
			          	}
	          		})
	}
	/** Standard Scale Bar Chart */
	if(metadata.charttypeselection == "BarChart"){
	        var bars = taxaGroup.append("g")
	          .attr("class", function(d) {
	              return "g-points "+d.ecolgroupid;
	          })
	          .selectAll("rect")
	          .data(function(d){
		          	  strataXScale.range(calcChartRange(d.maxvalue));
		          	  strataXScale.domain(calcChartDomain(d.maxvalue));
		              return d.values;
	          		}, function(d){
	          			return d.taxonname;
	          })
	          .enter()
	          .append("rect")
	          .attr("class",function(d,i){  
	          	return d.ecolgroupid +" standard-scale rect";
	          })
	          .attr("width", function(d){
	          	  //console.log("value: "+d.value+" | metadata.xscaleinput: "+ metadata.xscaleinput + " | "+d[metadata.xscaleinput]);
	          	  return strataXScale(d[metadata.xscaleinput]);
	          })
	          //.attr("cy", lang.hitch(this,function(d){
	          .attr("y", function(d){
	              return strataYScale(lookupYValueBySampleID(d.sampleid)) - 2/2; 
	          })
	          .attr("x",0)
	          .attr("height",2)
	          .style("fill",function(d,i){
	          	//only vertebrate fauna are styled here, the rest use CSS
	          	if(metadata.datasettype == "vertebrate fauna"){
		          	if(d.ecolgroupid && metadata.allecolgroupids){
		          		return colors20(metadata.allecolgroupids.indexOf(d.ecolgroupid));
		          	} else {
		          		return '#dddddd';
		          	}
	          	} else {
	          		return null;
	          	}
	          })
	}
	/** Symbol Plot **/
	if(metadata.charttypeselection == "SymbolPlot"){ 
	        var symbols = taxaGroup.append("g")
	          .attr("class", function(d) {
	              return "g-symbols "+d.ecolgroupid;
	          })
	          .selectAll("cross")
	          .data(function(d){
	          		  //define fixed width as global var
		          	  strataXScale.range([0, fixedWidth]);
		          	  strataXScale.domain([0,1]);
		              return d.values;
	          		}, function(d){
	          			return d.taxonname;
	          })
	          .enter()
	          .append("path")
	          .attr("class",function(d,i){  
	          	return d.ecolgroupid +" standard-scale";
	          })
			  .attr("transform", function(d){
	                return "translate("+strataXScale(0.5)+","+strataYScale(lookupYValueBySampleID(d.sampleid))+")";
	          })
	          .attr("d", symbolRenderer)
	          	//function(d){

	              //return d3.symbol(d).type(d3.symbolCross);
	              //var crossSymbol = d3.symbolCross.size([32]);
	              //d3.symbols[3]
	              //return d3.symbol({type: ["cross"] , size: 32})();
	          //})
	          .style("fill",function(d,i){
	          		//only vertebrate fauna are styled here, the rest use CSS
	          	if(metadata.datasettype == "vertebrate fauna"){
		          	if(d.ecolgroupid && metadata.allecolgroupids){
		          		return colors20(metadata.allecolgroupids.indexOf(d.ecolgroupid));
		          	} else {
		          		return '#dddddd';
		          	}
	          	} else {
	          		return null;
	          	}
	          })
	          .attr("id", function(d,i){
	                return "id_"+d.sampleid;
	          })
			  .on("mouseout", function(d){
				      tooltip.transition().duration(500).style("opacity", 0);                       
			  })
			  .on("mouseover",function(d){
				  	/*
				      var label = d3.format(".1%")(d.Abundance/100);
				     */
				     var label = constructMouseOverLabel(d);
				      tooltip.transition().duration(200).style("opacity", .9);
				      tooltip.html(label)
				      .style("left", (d3.event.pageX) + 5 + "px")     
				      .style("top", (d3.event.pageY) - 20 + "px"); 
			  });       
	}

	/**Numeric Data - Mouseover Point Display **/
	if(metadata.charttypeselection != "SymbolPlot"){
	        taxaGroup.append("g")
	          .attr("class", function(d) {
	              return "g-points "+d.ecolgroupid;
	          })
	          .selectAll("circle")
	          .data(function(d){
	          	  strataXScale.range(calcChartRange(d.maxvalue));
	          	  strataXScale.domain(calcChartDomain(d.maxvalue));	

	          	  //strataXScale.range(calcChartRange(d.maxAbundance));
	          	  //strataXScale.domain(calcChartDomain(d.maxAbundance));
	              return d.values;
	          }, function(d){
	          	return d.taxonname;
	          })
	          .enter()
	          .append("circle")
	          .attr("class",function(d,i){  
	          	return d.ecolgroupid;
	          })
	          .style("fill",function(d,i){
	          	//only vertebrate fauna are styled here, the rest use CSS
	          	if(metadata.datasetType == "vertebrate fauna"){
			         if(d.ecolgroupid && metadata.allecolgroupids){
			          		return colors20(metadata.allecolgroupids.indexOf(d.ecolgroupid));
			         } else {
			          		return '#dddddd';
			         }
	      		} else {
	      			return null;
	      		}
	      	  })	
	          .attr("cx", function(d){
	          	  return strataXScale(d[metadata.xscaleinput]);
	          })
	          //.attr("cy", lang.hitch(this,function(d){
	          .attr("cy", function(d){
	              return strataYScale(lookupYValueBySampleID(d.sampleid));
	          })
	          .attr("r",0)
	          .on("mouseout", function(d){
	              tooltip.transition().duration(500).style("opacity", 0);                       
	          })
	          .on("mouseover",function(d){
	          	/*
	              var label = d3.format(".1%")(d.Abundance/100);
	             */
	             var label = constructMouseOverLabel(d);
	              tooltip.transition().duration(200).style("opacity", .9);
	              tooltip.html(label)
	              .style("left", (d3.event.pageX) + 5 + "px")     
	              .style("top", (d3.event.pageY) - 20 + "px"); 
	        });        
	}
        function showPoints(){   
            taxaGroup.selectAll("circle")
            .attr("r",4);
        }

        function hidePoints(){
            taxaGroup.selectAll("circle")
            .attr("r",0);
        }

        function constructMouseOverLabel(ptdata){
        	
        	//cases differ for variableUnit
        	//cases differ for species and 'Other' aggregates
        	var labelType = metadata.variableunit;

        	if(labelType){
        		switch(labelType){
        			case "NISP":
        				metadata.variableunit = "NISP";
			        	metadata.yaxislabel = "Radiocarbon Years BP";
			        	metadata.yaxisunittype = "Age";
			        	metadata.yaxiscollection = ageCollection[0];
			        	

			        	var pctLabel = d3.format(".1%")(ptdata.abundance/100);
			        	var cntLabel;
			        	if(ptdata.nispcount){
			        		cntLabel = d3.format("c")(ptdata.nispcount); //integer
			        	} else {
			        		cntLabel = d3.format("c")(ptdata.value); //integer
			        	}
			        	var html = "";
			        	if(ptdata.ecolgroupid){
			        		var taxonName = ptdata.taxonname ? " | " +  ptdata.taxonname : " | (multiple)";
			        		html = "<h3>"+ptdata.ecolgroupid+ taxonName + "</h3><br>";
			        	}
			        	html += "<span>"+ptdata.sampleid +"<span><br>";
			        	html += "<span>"+metadata.yaxisunittype +": "+ lookupYValueBySampleID(ptdata.sampleid) + " " +metadata.yaxislabel + "</span><br>";
			        	html += "<span>Pct: "+pctLabel + "</span><br>";
        				html += "<span>Total Count: " + cntLabel + "</span><br>";
        				break;
        			default:
        				var html ="";
        				if(ptdata.ecolgroupid){
        					var taxonName = ptdata.taxonname ? " | " + ptdata.taxonname : " | (multiple)";
			        		html = "<h3>"+ptdata.ecolgroupid+ taxonName + "</h3><br>";
			        	}
        				html += "<span>"+ptdata.sampleid +"<span><br>";
			        	html += "<span>"+metadata.yaxisunittype +": "+ lookupYValueBySampleID(ptdata.sampleid) + " " +metadata.yaxislabel + "</span><br>";
			     		//html += "<span>Value: " + ptdata.Value + "</span><br>";
			     		break;   	
        		}
        	}
        	
        	
        	
        	return html;
        	
        }

        //bottom axis
        var offset = height + 8;
        
        chartComponents.append("g")
            .attr("class","x axis bottom")
            .each(function(d,i){
            	//strataXScale.range(calcChartRange(d.maxAbundance));
            	strataXScale.range(calcChartRange(d.maxvalue));
          	  	//strataXScale.domain(calcChartDomain(d.maxAbundance));
          	  	strataXScale.domain(calcChartDomain(d.maxvalue));
          	  	//var intervals = Math.ceil(d.maxAbundance/5);
          	  	var intervals = Math.ceil(d.maxvalue/5);
          	  	abundAxisBottom.tickValues(calcTickMarks(intervals));
          	  	d3.select(this).call(abundAxisBottom);
            })
            .attr("transform", "translate(0,"+offset+")");
        

        //top x axis    
        chartComponents.append("g")
            .attr("class","x axis top")
            .each(function(d,i){
            	//strataXScale.range(calcChartRange(d.maxAbundance));
            	strataXScale.range(calcChartRange(d.maxvalue));
          	  	//strataXScale.domain(calcChartDomain(d.maxAbundance));
          	  	strataXScale.domain(calcChartDomain(d.maxvalue));
          	  	//var intervals = Math.ceil(d.maxAbundance/5);
          	  	var intervals = Math.ceil(d.maxvalue/5);
          	  	abundAxisBottom.tickValues(calcTickMarks(intervals));
          	  	d3.select(this).call(abundAxisBottom);
            })
            .attr("transform", "translate(0,-8)");

        //y axis
        var yAxisElement = d3.select(".g-taxa-group")
		    .append("g")
	        .attr("class","y axis")
	        .call(yAxis)
	        .attr("transform", "translate(-10,0)");

	    //format axis ticks
	    var ticks = d3.selectAll(".taxa-chart")
	    	.selectAll(".tick")      
              .attr("class",function(d,i){
                  if( i % 2 > 0){
                      return "odd";
                  } else {
                      return "even";
                  }
        });


        var oddTickLines = d3.selectAll(".taxa-chart")
        	.selectAll(".top")
          .selectAll(".odd")
          .selectAll("line")
          .attr("y2", -12);

        var oddTickLines = d3.selectAll(".taxa-chart")
        	.selectAll(".top")
          .selectAll(".even")
          .selectAll("line")
          .attr("y2", -6);
  
        
		updateYAxisLabel();

		updateXAxisLabel();

	}
	//end renderNewData()

	function updateXAxisLabel(){
		var width=0; 
		var l;
		l = dojo.query(".taxa-group");

		l.forEach(function(i){
			width += i.offsetWidth;
		});
		//console.log("width is: "+width);
		var c = dojo.query(".charts")[0];
		c.setAttribute("style","width:"+width+"px");

	}

	function renderUpdates(){

	}

	function renderNewChartType(){

	}



    function toggleExaggeration(){
    	 var value = !document.getElementById("showExaggeration").checked;
  
		 d3.selectAll(".exaggerate-5x")
		    .classed(["hide"],value);
    }

    function toggleAreaChart(){
    	 var value = !document.getElementById("showAreaChart").checked;
  
		 d3.selectAll(".area")
		    .classed(["hide"],value);
    }

    function updateCharts(){
    	
        var extent;

		extent = metadata.yaxisdomainextent;
                    
        strataYScale.domain(extent);



        d3.select(".y.axis")
          .selectAll("g")
          .remove();

        d3.select(".y.axis")
          .transition().duration(500)        
          .call(yAxis);



       if(metadata.charttypeselection == "FilledArea"){
        //redraw lines
        var exagPaths = d3.selectAll("path.exaggerate-5x")               
              .transition().duration(500) 
              .attr("d", function(d) { 
                  return taxaarea5x(d.values);
              });    

        var paths = d3.selectAll("path.standard-scale")
              .transition().duration(500)       
              .attr("d", function(d) {
                  return taxaarea(d.values);
              });

        var mouseoverpts = d3.selectAll(".g-points")
          .selectAll("circle")    
          .attr("cy", function(d){        
              var yPosition;
              yPosition = strataYScale(lookupYValueBySampleID(d.sampleid));
              return yPosition;       
          });
        }

        if(metadata.charttypeselection == "BarChart"){
        	var rects = d3.selectAll("rect")
	          .attr("width", function(d){
	          	  console.log("value: "+d.value+" | metadata.xscaleinput: "+ metadata.xscaleinput + " | "+d[metadata.xscaleinput]);
	          	  return strataXScale(d[metadata.xscaleinput]);
	          })
	          //.attr("cy", lang.hitch(this,function(d){
	          .attr("y", function(d){
	              return strataYScale(lookupYValueBySampleID(d.sampleid)) - 2/2; 
	          })
        }

        if(metadata.charttypeselection == "Symbol Plot"){
        	console.log("plot symbols");
        }
        //check if 5x should be drawn  
        //toggleExaggeration();

        //update y axis label
        //var firstChart = d3.select(".y-axis-label")

        var firstChart = d3.select(".y-axis-label")
          .text(metadata.yaxislabel);
    }

	//apiDownloadDataset(defaultDatasetID);
	
	////////setDefaultSelection();
	function handleFormChange(evt){
		//handle new selections only, ignore deselected evts: evt == false
		if (evt){
			console.log("handleFormChange evt", evt);
			require(["dijit/form/Form", "dijit/registry"],function(Form, registry){
				var interactionForm = registry.byId("interactionForm");
				var currentSelections = interactionForm.get("value");
				//set charttype selection on metadata
				metadata.charttypeselection = currentSelections.chartTypeRadioButtons;

				if(initialized){
					updateChart();
				}
			})
		}
	}

	function testHandler(evt){
		console.log("test handler");
	}

	function handleGenusGroupChange(evt){
		//text input change
	}

	function handleApplyFilterAndGroup(evt){
		//user clicked apply
		updateChart();
	}

	function clearDatasetType(){
		require(["dijit/registry"],function(registry){
			var dijitfsDataType = dijit.registry.byId("fsDataType");
			if(dijitfsDataType){
				dijitfsDataType.set("value",null);
			}
		});
	}

	function clearDatasetID(){
		require(["dijit/registry"],function(registry){
			var dijitfsDatasetID = dijit.registry.byId("fsDatasetID");
			if(dijitfsDatasetID){
				dijitfsDatasetID.set("value",null);
			}
		});
	}


	

    	
</script>
</html>

